"""Basic example of parallel random sampling with simulations."""

from math import gamma, pi, sqrt
import numpy as np
from libensemble.generators import APOSMM
import libensemble.gen_funcs

libensemble.gen_funcs.rc.aposmm_optimizers = "nlopt"
from optimas.core import VaryingParameter, Objective
from libensemble.tests.regression_tests.support import (
    six_hump_camel_minima as known_minima,
)

# from optimas.generators import RandomSamplingGenerator
from optimas.generators import APOSMMWrapper
from optimas.evaluators import TemplateEvaluator
from optimas.explorations import Exploration

from multiprocessing import set_start_method

set_start_method("fork", force=True)


def analyze_simulation(simulation_directory, output_params):
    """Analyze the simulation output.

    This method analyzes the output generated by the simulation to
    obtain the value of the optimization objective and other analyzed
    parameters, if specified. The value of these parameters has to be
    given to the `output_params` dictionary.

    Parameters
    ----------
    simulation_directory : str
        Path to the simulation folder where the output was generated.
    output_params : dict
        Dictionary where the value of the objectives and analyzed parameters
        will be stored. There is one entry per parameter, where the key
        is the name of the parameter given by the user.

    Returns
    -------
    dict
        The `output_params` dictionary with the results from the analysis.

    """
    # Read back result from file
    with open("result.txt") as f:
        result = float(f.read())
    # Fill in output parameters.
    output_params["f"] = result
    return output_params


# Create varying parameters and objectives.
var_1 = VaryingParameter("x0", -3.0, 3.0)
var_2 = VaryingParameter("x1", -2.0, 2.0)
obj = Objective("f")

n = 2

aposmm = APOSMM(
    initial_sample_size=100,
    localopt_method="LN_BOBYQA",
    sample_points=np.round(known_minima, 1),
    rk_const=0.5 * ((gamma(1 + (n / 2)) * 5) ** (1 / n)) / sqrt(pi),
    xtol_abs=1e-5,
    ftol_abs=1e-5,
    dist_to_bound_multiple=0.5,
    max_active_runs=4,  # refers to APOSMM's simul local optimization runs
    lb=np.array([var_1.lower_bound, var_2.lower_bound]),
    ub=np.array([var_1.upper_bound, var_2.upper_bound]),
)

gen = APOSMMWrapper(
    varying_parameters=[var_1, var_2],
    objectives=[obj],
    libe_gen=aposmm,
)

# Create evaluator.
ev = TemplateEvaluator(
    sim_template="template_simulation_script.py",
    analysis_func=analyze_simulation,
)


# Create exploration.
exp = Exploration(
    generator=gen, evaluator=ev, max_evals=300, sim_workers=4, run_async=True
)


# To safely perform exploration, run it in the block below (this is needed
# for some flavours of multiprocessing, namely spawn and forkserver)
if __name__ == "__main__":
    exp.run(100)
    exp.run(200)
    exp.finalize()

    assert len(gen.libe_gen.all_local_minima)
    print(f"Found {len(gen.libe_gen.all_local_minima)} minima!")
    found_minima = [i["x"] for i in gen.libe_gen.all_local_minima]
    found_minima_combined = np.zeros(
        len(gen.libe_gen.all_local_minima), dtype=(float, 2)
    )
    for i in range(len(found_minima)):
        found_minima_combined[i] = found_minima[i][0]
    found_minima = found_minima_combined
    known_minima = np.round(known_minima, 3)  # much precision lost?
    found_minima = np.round(found_minima, 3)
    assert any([i in known_minima for i in found_minima])
